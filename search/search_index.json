{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuTech - Data &amp; Software","text":"<p>Are you a researcher?</p> <p>Are you looking to work with either data or software?</p> <p>Then this site if for you!</p>"},{"location":"data/","title":"Data","text":""},{"location":"software/","title":"Software","text":""},{"location":"software/FAIR/","title":"FAIR Software (QSMM 2)","text":""},{"location":"software/FAIR/#why","title":"Why?","text":"<p>During your time at QuTech chances are high that you are going to write some piece of software. This could be a simple script to analyze your data, a python library you want to share with your fellow researchers or perhaps even some software you want to share with the outside world. For some of the software that you are going to write it is advantageous to have your software be reproducible.</p> <p>Being mindful of software reproducibility can help you if you have encountered the following problems before:</p> <ul> <li>You wrote a script to analyze some data a few months ago, you now have new data. You can either no longer find the script or you can no longer get the script to work.</li> <li>You want to collaborate on research with other people. A vital script for the research only works on your laptop. You have been condemned to run the script for your colleagues for all of eternity.</li> <li>You finally got your script working. You barely dare to use your laptop to watch Netflix out of fear of breaking your script.</li> <li>You analyzed some data and started putting the results in your paper. While writing you notice some inconsistencies in the results, you dig into your script and find out it is not doing what you expected.</li> </ul> <p>In general it will also make your research more valuable to QuTech and the research community:</p> <ul> <li>Making it easier to reproduce the results of your research</li> <li>Making it more transparent.</li> <li>Making it easier to re-use your work in other research. Your software can have a legacy within QuTech or the research community, even after you have finished your own research.</li> </ul> <p>FAIR Data and Software is also becoming more of a hot topic each day in the research world. In the future it is likely that these principles become more important also in relation to the quality and funding of research. Already learning how to apply these principles to software will help you be ahead of the curve!</p>"},{"location":"software/FAIR/#how","title":"How?","text":"<p>At QuTech we have defined a QuTech Software Maturity Model (QSMM) to help reason about software quality. The basic idea is that we define 4 maturity levels, depending on how the software will be used. For each level we define certain aspects which should be considered when developing software of this maturity level. To give an idea we show the levels with an example of what kind of software would fit this maturity:</p> Level Purpose Examples 1 - Prototype One off scripts, only used by a single individual Initial scripts used to explore your data. 2 - Repeatable Scripts for use within a group, scripts used for papers Script used to perform data analysis for a paper, software for a piece of hardware only used in your group 3 - Mature Software used within multiple groups Quantum Measurement Interface (QMI) 4 - Defined Software for use within and outside of QuTech Quantum Inspire, Quantum Network Explorer <p>We mostly want to focus here on level 1 and 2 because this is what most researchers will write at QuTech. If you do want to write software of higher levels you can of course ask the SDST for help!</p> <p>Level 1 is intended for scripts that are only used by one individual just to for example quickly look through some newly generated data. With scripts of this category it is less important if there are some small bugs or if someone else cannot reproduce your results. They will most likely end up in the bin fairly quickly after being used.</p> <p>A lot of research software also falls in category 2. With this software it is important that it can be reproduced. Whether that is by yourself when you want to run a similar or the same experiment again, or by someone else. Software that is used to actually run an experiment or analysis of data used in papers falls in this category. We often see that software that should have this maturity level is not actually easy to reproduce within QuTech. While making it reproducible often requires you to invest a little bit more time in the beginning of your project, we expect that throughout the duration of the project it will end up saving your time. We also provide you with some resources in the next section to get you started quickly.</p>"},{"location":"software/FAIR/#what","title":"What?","text":"<ul> <li> <p>Most software at QuTech is developed in Python. We have a template to get you started quickly with these principles in Python. With the template you can quickly create your python project adhering to QSMM 2 by answering a few simple questions. The template can be found on github.</p> </li> <li> <p>There are also a few courses related to software development and reproducible software which can be followed for Graduate School Credits. </p> </li> <li>(1.5 GS credits) A course about Git</li> <li>(2.5 GS credits) A more general course to refine your coding skills, which includes an introduction to Git</li> <li>(1.5 GS credits) A programming introduction course for researches with little to no experience with programming, which includes an introduction to Git</li> <li>For those that are interested in software quality in general other pages on this site also provides some info on other related topics and additional resources to learn more.</li> <li>The SDST is also available if you have questions about any of these topics or if you need some help with using the templates for example.</li> </ul>"},{"location":"software/testing/","title":"Sofware Testing","text":""},{"location":"software/testing/#why","title":"Why?","text":"<ul> <li>You analyzed some data and started putting the results in your paper. While writing you notice some inconsistencies in the results, you dig into your script and find out it is not doing what you expected.</li> <li>You know the output of your software is not correct. But it is difficult to figure out where in your code you made a mistake.</li> <li>You have received some code from a colleague. You have been assured it works. You start running the code, for your input you are suddenly getting errors or wildly inaccurate results.</li> </ul> <p>Software testing has the following advantages:</p> <ul> <li>It improves the maintainability of your code. By automatically being able to test your software you can be more certain that you did not break anything in your code.</li> <li>It makes it easier to spot mistakes. Having automated tests can help you pinpoint where in your software you have made a mistake.</li> <li>It gives you, and others, more confidence in the correctness of the results.</li> <li>Since you define the expected inputs and outputs tests can also serve as a form of documentation. It makes clear what the expectations are for a certain piece of your software and therefore also gives some information on how it can be used.</li> </ul>"},{"location":"software/testing/#what","title":"What?","text":"<p>When we talk about (automated) software testing then we define a few types of tests. The main categories are:</p> <ul> <li>End-to-end tests: These test the full working of your software. In the case of a simple script this could be a test which provides an input file and checks if the expected output file is created.</li> <li>Unit tests: Unit tests test a smaller piece (unit) of your software. This can be for example a test of a single function which is used to process your results.</li> <li>Integration tests: Integration tests test your integrations with 3rd party services. E.g. if your application makes use of some third party software you test if the system works as expected when you combine your code with this third party software.</li> <li>Performance tests:  As the name suggests these test the performance of the system (e.g. how fast is a certain analysis?).</li> </ul> <p>When dealing with more simple research projects you are most likely interested in the first two: end-to-end tests and unit tests. When you are just starting out with automated testing we suggest focusing on end-to-end tests first as these will give you the best idea about whether your full software works as expected. Unit tests can then be used to more specifically test complex edge cases of a certain function or to pinpoint where the mistakes are in your code.</p>"},{"location":"software/testing/#how","title":"How?","text":""},{"location":"software/testing/#tools","title":"Tools","text":"<p>If you are working in Python, then Python has a pretty good built in testing framework for unit tests, called unittest. Especially if you are working with jupyter notebooks then Python\u2019s builtin framework called doctest might also be useful. The doctest framework allows you to define some simple tests in comments in your code. If you add these comments to your jupyter notebook then jupyter notebook will also complain when it detects an error in these test cases. Additionally within the Python community pytest is also commonly used, it is often seen as being easier to read than the built-in unittest framework.</p>"},{"location":"software/testing/#usage-of-the-tools","title":"Usage of the tools","text":"<p>To start with software testing you need to consider two important questions:</p> <ul> <li>What is the expected behaviour of the software on certain inputs?</li> <li>What are the edge cases of this behaviour?</li> <li>With this we mean: for which cases should the software do something differently than the \u201cnormal\u201d flow. A simple example is a division function. If the divider is 0 then a division is not possible so instead an error should be thrown. In our tests we would therefore check:<ul> <li>That the correct result is produced when the divider is something different than 0.</li> <li>That an error is thrown when the divider is 0.</li> </ul> </li> </ul> <p>If you have answered these two questions you can start creating test cases which check this behaviour and their edge cases.</p>"},{"location":"software/testing/#courses","title":"Courses","text":"<p>Want to learn more about software testing?</p> <ul> <li>If you want to increase your software development skills in general then the library offers a coderefinery course which you can get graduate school credits for. This course is meant for people who already are able to program but would like to improve their skills. It also includes a part about software testing.</li> <li>If you want to learn more about advanced software testing topics then the TU Delft also offers some MOOCs on software testing. These are mostly here for people with a deep interest in software testing. We do not expect that you need the skills from these courses in your normal research.</li> <li>Automated Software Testing: Unit Testing, Coverage Criteria and Design for Testability</li> <li>Automated Software Testing: Model and State-based Testing</li> <li>Automated Software testing in Java</li> </ul>"},{"location":"software/vcs/","title":"Version Control Systems","text":"<p>This page gives some information about version control systems. If you are already familiar with those you might want to skip ahead to see if the additional resources offer something new to learn for you. On this page we give a short description of the version control infrastructure available to researches at QuTech. If version control systems are new for you then we will begin by explaining which problems they can help solve, how they do this and what tools you can use for this.</p>"},{"location":"software/vcs/#why","title":"Why?","text":"<p>If you have previously developed code you might have experienced some of the following problems:</p> <ul> <li>Something that previously worked is suddenly broken. It takes a long time to bring it back to a working state.</li> <li>You have accidentally deleted some code, the laptop with your precious code on it was stolen or you have lost code in some other way.</li> <li>You want to collaborate on code, but it is not easy to work on the same project at the same time with your colleagues.</li> <li>You or someone else wants to reproduce results you have obtained in the past, but you have changed the code and the results have changed.</li> </ul> <p>Version control systems have been created to tackle exactly these types of problems when developing software. How they do that and which systems are available for it in QuTech will be explained next.</p>"},{"location":"software/vcs/#how","title":"How?","text":"<p>Version control systems work with a local version and a remote version of your code. The place where your code is stored is called a repository. Each developer can start working in a local repository on their own computer. Once they are finished making changes they upload (called push) their local repository to synchronize it with the remote repository. In this way your code is always backed up in a remote location. Since it is backed up on a server you can also use this remote copy to share your code with others or to collaborate on the code.</p> <p>The version control systems, as the name implies, also has a form of versioning. When new code is pushed to the remote repository the system does more than just saving this latest version. The system keeps track of the changes that have been made in the past and therefore also allows you to look through the history of your code and to retrieve old versions. This has several advantages. You can change your code without being scared of breaking it, you can always go back to a working version. You can easily use and share old versions of your code to reproduce old results. You can figure out when something changed, who changed it and why it was changed.</p> <p>Additionally version control systems have a concept called branches, which allows for more advanced collaboration. If you just want to use version control systems as a solo developer you probably do not need to think about this. We briefly cover the topic of branches here though: Branches allow you to \u201cbranch off\u201d. When you do this you create a new copy of your code which is stored separately from your main code (stored on the main branch). You can then start making changes on this branch and once you are finished you can add the changes you have made back your main branch, incorporating them into your \u201cnormal\u201d code. This allows for more collaboration on the same codebase. Different features for example can be worked on simultaneously on different branches.</p> <p>There are different philosophies about how you can use these branches to collaborate, each having their own advantages and disadvantages. We will give some more information on these different workflows in the additional resources. If you are unsure how best work with the branches for your project you can also ask the SDST for advice.</p>"},{"location":"software/vcs/#what","title":"What?","text":"<p>There are different version control systems. At QuTech mostly Git is used, this is also one of the most popular version control systems. The additional resources section provides information on learning Git if you are not yet familiar with it. If you are familiar it also offers some advanced topics if you want to learn more.</p> <p>As mentioned version control systems store your code remotely. This means that next to a system such as Git you also need a server to store the code on. There are a few options for this. The two most popular options are GitHub and GitLab. At QuTech we also have the possibility to use a version of GitLab hosted by the TU Delft. Your research group might already have a preferred option so you might want to ask your supervisor what is used in your group. If your research group does not have a preferred option yet you can ask the SDST for help with selecting one.</p>"},{"location":"software/vcs/#additional-resources","title":"Additional Resources","text":"<p>Interested in version control systems, but unsure how to continue from here? You can always ask the SDST for help/advice on this topic. Additionally if you want to learn more about Git we provide some resources for you here.</p>"},{"location":"software/vcs/#all-levels","title":"All Levels","text":"<ul> <li>Need a reminder of the commands used in Git? GitHub has a convenient cheat sheet:</li> <li>Would you rather use a GUI instead of (or in combination with) command line commands? A few different GUIs are availabe, some examples:</li> <li>Sourcetree:<ul> <li>Free and popular GUI with a lot of features</li> </ul> </li> <li>Fork<ul> <li>Free at the moment, most likely will cost some money in the future</li> </ul> </li> <li>GitHub Desktop<ul> <li>Free. Generally easy to use, but tailored to GitHub specifically</li> </ul> </li> </ul>"},{"location":"software/vcs/#beginners","title":"Beginners","text":"<p>Want to learn the basics of Git?</p> <ul> <li>The TU Delft library offers three different courses which teach you about Git (and give you graduate school credits!)</li> <li>(1.5 GS credits) A course about Git</li> <li>(2.5 GS credits) A more general course to refine your coding skills, which includes an introduction to Git</li> <li>(1.5 GS credits) A programming introduction course for researches with little to no experience with programming, which includes an introduction to Git</li> <li>Would you rather learn more about Git at your own pace?</li> <li>This short freecodecamp tutorial explains how to get started with Git and GitHub</li> <li>Want to learn Git while sovling puzzles? This interactive game teaches you about Git commands (you might need to disable your adblocker if you have one for it to work properly)</li> </ul>"},{"location":"software/vcs/#intermediateadvanced","title":"Intermediate/Advanced","text":"<ul> <li>Do you know the basics, but want to know more about workflows to use Git to collaborate?</li> <li>GitLab has an overview of some different workflows and their advantages:  </li> <li>In this article Atlassian describes the basic \u201cCentralized Workflow\u201d and links to elaborate descriptions of other workflows</li> </ul>"}]}